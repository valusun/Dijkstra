- Dijkstra
グラフの最短距離を求めるアルゴリズム
スタート地点を0とし、繋がっている頂点に遷移し最短距離であれば更新していく

- 計算量
O((E+V) log V) ... 優先度付きキュー(二分ヒープ)

- メリット
高速

- デメリット
ちょっと難解

- 優先度付きキュー
<Python>
import heapqのheapifyで優先度付きキューを使用できる
(同ファイルでは使用していない)
deappop()で第一要素が最小のものから取り出してくれる

<c++>
priority_queueで使用できる
pop()で取り出すのは、値が大きいものを優先的に取り出すので注意

優先度付きキューを使用することで、距離が最短のものから取り出していくことが出来る。

- 補足
因みに、辺の重みが同一であれば幅優先探索(BFS)を使った方が早い
また、辺の重みが0/1であれば、0の場合はQの先頭に追加/1の場合は末尾に追加していくことで優先度付きキューを使用しなくても解ける

- 例題
https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_A&lang=ja

-- ざっくりと説明
頂点数(V)と辺の数(E)とスタート地点(r)と各辺の情報(s(遷移元),t(遷移先),d(重み))が与えられる。
頂点1からVまでの最短距離を順番に出力せよ。
遷移不能な頂点に関しては"INF"と出力すること。

<入力書式>
V E r
s1 t1 d1
...
sE tE dE

<制約>
1 <= V <= 100000
0 <= E <= 500000
0 <= d <= 10000
多重辺/自己ループなし

<入力例>
4 6 1
0 1 1
0 2 4
2 0 1
1 2 2
3 1 1
3 2 5

<出力例>
3
0
2
INF
